[ { "title": "Required and Optional arguments", "url": "/Cliargs.NET/basic-usage/required-optional-argument/", "categories": "Basic usage", "tags": "", "date": "2022-03-23 00:00:00 +0100", "snippet": "The difference between required and optional arguments, is that Cliargs.NET throws an exception during the initlization process when missing a required argument, while continues the initialization in a normal way if any optional argument is missing. Each argument is created by default as required unless you make it optionalRequired argumentArguments are created as required by default, but if needed, to set an argument as required, you have two ways to follow, either by setting the ArgumentInfo.Optional property to false, or by calling the extension method AsRequired when creating your argument instance during the registration step.// Setting the Argument Info property var usernameArg = new CliArg&amp;lt;string&amp;gt;(new CliArgsInfo(&quot;Username&quot;));usernameArg.Info.Optional = false; // default is false. // Setting during the argument creation // Set it as optionalvar usernameArg = CliArg.New&amp;lt;string&amp;gt;(&quot;Username&quot;) .AsRequired();Optional argumentTo set an argument as optional, you have two ways to follow, either by setting the ArgumentInfo.Optional property to true, or by calling the extension method AsOptional when creating your argument instance during the registration step.// Setting the Argument Info property var usernameArg = new CliArg&amp;lt;string&amp;gt;(new CliArgsInfo(&quot;Username&quot;));usernameArg.Info.Optional = true; // or false even if is default. // Setting during the argument creation // Set it as optionalvar usernameArg = CliArg.New&amp;lt;string&amp;gt;(&quot;Username&quot;) .AsOptional();Argument with default valueAn optional argument could have a default value, this value is used as argument value if the end-user doesn’t provide the value for the argument.The default value is set when creating the instance of the argument during the registration step, by calling the method AsOptional(defaultValue).// Setting during the argument creation // Set it as optionalvar usernameArg = CliArg.New&amp;lt;string&amp;gt;(&quot;Username&quot;) .AsOptional(&quot;Guest&quot;); // The default username is guest Required arguments have no default value. The value must be entered by the user." }, { "title": "Regex Rule", "url": "/Cliargs.NET/validation-rules/regex-rule/", "categories": "Validation Rules", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The Regex Rule is a validation rule allows you to validate the user input using a regular expression pattern.Create an instanceTo create an instance of the Regex rule, either you use the default constructor or use the static method WithPattern(string pattern).Example below, to set a conditional rule for integer value that must be greater than 0.// Default rule constructor new RegexRule(&quot;.*&quot;);// With static pattern methodRegexRule.WithPattern(&quot;.*&quot;);If you are familiar with Regular Expressions on C#, you can specify the Regex Options.// Default rule constructor new RegexRule(&quot;.*&quot;, RegexOptions.IgnoreCase);// With static pattern methodRegexRule.WithPattern(&quot;.*&quot;, RegexOptions.IgnoreCase);Set the validation error messageYou can customize the validation error message to show to the end-user if the validation fails by calling the method WithValidationError(string validationError).myConditionalRule = myConditionalRule.WithValidationError(&quot;My custom validation error message&quot;);Examplevar regexRule = RegexRule.WithPattern(&quot;\\d&quot;) .WithValidationError(&quot;The value doesn&#39;t match the defined pattern, only numbers expected.&quot;);" }, { "title": "Value in Range Rule", "url": "/Cliargs.NET/validation-rules/range-validation-rule/", "categories": "Validation Rules", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "This rule checks if a given value is present in a range.ExampleThis example to ensure an input Integer value is in a range of [1, 2, 3]// pass the items of the rangeRangeValidationRule&amp;lt;int?&amp;gt;.FromRange(1, 2, 3 ); // Or create a range from a collectionRangeValidationRule&amp;lt;int?&amp;gt;.FromRangeCollection(new int?[] { 1, 2, 3 });" }, { "title": "Directory exists", "url": "/Cliargs.NET/validation-rules/direcory-exists-rule/", "categories": "Validation Rules", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "This rule ensure that a directory exists from a given path.Usage:Just add a new instance of DirectoryExistsRule to argument validation rules when initializing the directory argument object.myDirectoryArg = myDirectoryArg.WithValidationRule(new DirectoryExistsRule());" }, { "title": "Conditional Rule", "url": "/Cliargs.NET/validation-rules/conditional-rule/", "categories": "Validation Rules", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The Conditional Rule is very generic allows you to customize the condition to validate the value using lambda expressions.Create an instanceTo create an instance of the Conditional rule, either you use the default constructor or use the static method WithCondition.Example below, to set a conditional rule for integer value that must be greater than 0.// Default rule constructor new ConditionalRule&amp;lt;int&amp;gt;(value=&amp;gt; value&amp;gt; 0);// With static methodConditionalRule&amp;lt;int&amp;gt;.WithCondition(value =&amp;gt; value &amp;gt; 0);Set the validation error messageYou can customize the validation error message to show to the end-user if the validation fails by calling the method WithValidationError(string validationError).myConditionalRule = myConditionalRule.WithValidationError(&quot;My custom validation error message&quot;);ExampleConditionalRule&amp;lt;int&amp;gt;.WithCondition(value =&amp;gt; value &amp;gt; 18) .WithValidationError(&quot;Age must be greater than 18 years old.&quot;);" }, { "title": "Comparaison rules", "url": "/Cliargs.NET/validation-rules/comparaison-rules/", "categories": "Validation Rules", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Cliargs comes with some native rules for comparing some dotnet types (Integer, Double…). This rules could be used directly or customized.EqualsRuleThis rule checks whether a given value equals to another one.// Create a new instance using the constructor new EqualsRule&amp;lt;string&amp;gt;(&quot;Sample String&quot;);// Or use the Value method to get a new instanceEqualsRule&amp;lt;int&amp;gt;.Value(3); GreaterThanRuleThis rule checks if a given value is greater than another value.// Use the rule constructor to create a new instance new GreaterThanRule&amp;lt;string&amp;gt;(&quot;C&quot;);// Or Use the static `Value` method to get a new instanceGreaterThanRule&amp;lt;int&amp;gt;.Value(1);GreaterThanOrEqualsRuleThis rule is similar to GreaterThanRule but it checks if a given value is greater than or equals to another value.// Create a new instance using the rule constructor new GreaterThanOrEqualsRule&amp;lt;FakeEnum&amp;gt;(FakeEnum.EnumElement); // Use the static `Value` method to get a new instanceGreaterThanOrEqualsRule&amp;lt;int&amp;gt;.Value(1);LessThanRuleThis rule checks if a given value is less than another value.// Use the rule constructor to create a new instance new LessThanRule&amp;lt;string&amp;gt;(&quot;C&quot;);// Or Use the static `Value` method to get a new instanceLessThanRule&amp;lt;int&amp;gt;.Value(1);LessThanOrEqualsRuleThis rule is similar to LessThanRule but it checks if a given value is less than or equals to another value.// Create a new instance using the rule constructor new LessThanOrEqualsRule&amp;lt;FakeEnum&amp;gt;(FakeEnum.EnumElement); // Use the static `Value` method to get a new instanceLessThanOrEqualsRule&amp;lt;int&amp;gt;.Value(1);" }, { "title": "Upgrade version", "url": "/Cliargs.NET/get-started/upgrade/", "categories": "Get Started", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Upgrade on a specific projectUpdate-Package Cliargs.NET -ProjectName MyProjectUpgrade to a particular versionUpdate-Package Cliargs.NET -version 1.2.3Upgrade to latest Pre-release verionUpdate-Package Cliargs.NET -PreRelease For more information about Nuget packages update, visit the official documentation from Microsoft." }, { "title": "Quick Startup", "url": "/Cliargs.NET/get-started/quick-startup/", "categories": "Get Started", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "In order to start using Cliargs.NET successfully, there are some steps to follow, In this quick startup, we try to build a sample console application that displays the user name, the age and highlight the output on demand.The name is mandatory argument, while the age is not. the user has the possiblity to choose to highlight the console output or not, using the option --highlight. The full example could be found on Github repository1. Create a Setup classThe Setup class is the main class hosting the configuration of the Cliargs.NET, this class must have the method Configure implemented.All arguments must be declared in this method, so Cliargs will know exactly what arguments to look for, the type of each argument, the category (Required, optional…).Also for each argument there are a set of other options to be set during the argument initialization.public class CliArgsSetup : ICliArgsSetup{ public void Configure(ICliArgsContainer container) { // The user real name container.Register( CliArg.New&amp;lt;string&amp;gt;(&quot;Name&quot;) .AsRequired() .WithLongName(&quot;name&quot;) .WithShortName(&quot;n&quot;) .WithDescription(&quot;The user real name&quot;) .WithUsage($&quot;-n|--name \\&quot;John Doe\\&quot;&quot;) ); // The user real age container.Register( CliArg.New&amp;lt;uint&amp;gt;(&quot;Age&quot;) .AsOptional() .WithLongName(&quot;age&quot;) .WithShortName(&quot;a&quot;) .WithDescription(&quot;The user age in years&quot;) .WithUsage(&quot;-a|--age 28&quot;) ); // Option to highlight the output container.Register( CliArg.New(&quot;Highlight&quot;) .AsOptional() .WithLongName(&quot;highlight&quot;) .WithShortName(&quot;hl&quot;) .WithDescription(&quot;Highlight the output in color&quot;) .WithUsage(&quot;-hl|--highlight&quot;) ); }}2. Initialize the AppCliArgs instanceThe AppCliArgs is the main instance that host the CLI arguments with their values. It also analyze, parse and validate the data entered by the user. During the initialization process some exceptions may be thrown in case of missing non-optional arguments, or when a wrong value has been typed.try { AppCliArgs.Initialize&amp;lt;CliArgsSetup&amp;gt;(new CustomFormat());}catch(CliArgsException exception){ Console.WriteLine($&quot;Error: {exception.Message}&quot;); return;} 3. Manage ExceptionsCurrently, there are some known exceptions that might be handled after the initialization, such us checking if the user request to see the help section, or if there were a validation errors on the user input.Other kind of exceptions might be a thrown CliArgsException, in this case, a clear message is set, or even, an inner exception is attached to the thrown exception.if(AppCliArgs.IsHelpRequested()){ Console.WriteLine(AppCliArgs.GetHelpString()); return;}if(AppCliArgs.HasValidationErrors){ var validationResults = AppCliArgs.GetValidationResults(); foreach (var result in validationResults) { Console.WriteLine(result.GetReport()); } return;}4. Start using the command line interface arguments valuesOnce the initialization and exceptions management are completed, you can start retrieving the values using the AppCliArgs.GetValue Method.All the required arguments should be there, except the optional arguments, where a quick check for existence is recommended using the method AppCliArgs.IsSet.var name = AppCliArgs.GetArgValue&amp;lt;string&amp;gt;(&quot;Name&quot;);uint? age = null;bool highlight = AppCliArgs.IsSet(&quot;Highlight&quot;);string output = $&quot;Hello {name}, we don&#39;t know your age!&quot;;if(AppCliArgs.IsSet(&quot;Age&quot;)) { age = AppCliArgs.GetArgValue&amp;lt;uint&amp;gt;(&quot;Age&quot;); output = $&quot;Hello {name}, You are {age} years old!&quot;;}if(highlight) { Console.BackgroundColor = ConsoleColor.Yellow; Console.ForegroundColor = ConsoleColor.DarkRed;}Console.WriteLine(output);if(highlight) Console.ResetColor();" }, { "title": "Installation", "url": "/Cliargs.NET/get-started/Installaltion/", "categories": "Get Started", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "There are several ways to install Cliargs.NET library, depending on your environment and your preferences.Nuget Package ManagerInstall-Package Cliargs.NETFrom dotnet CLIdotnet add package Cliargs.NETRaw Pacakge DownloadThe raw nupkg file could be downloaded from Nuget pacakge page" }, { "title": "Parse argument into object", "url": "/Cliargs.NET/basic-usage/parse-args-into-object/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Cliargs.NET allows to parse all arguments into a given object properties, this operation is done in several steps.Set argument propertiesEach property that corresponds to an argument must have the same type as the argument and has an attribute CliArgNameAttribute.ExampleIf you have set an argument Age with type uint like the following:container.Register( CliArg.New&amp;lt;uint&amp;gt;(&quot;UserAge&quot;) .WithLongName(&quot;age&quot;) .WithShortName(&quot;a&quot;) );Then the property where the data is parsed it should be similar than in the following code:public class MyArgs { [CliArgName(&quot;UserAge&quot;)] public uint? Age {get; set;} } The attribute CliArgName has an optional parameter string? name = default which is the name of the argument (in the example above is UserAge). Setting the argument name is not required if the property has the same name than the argument.Parse the dataOnce Cliargs initiliazation is completed without errors, you can start the parsing by calling the method GetArgsParsed&amp;lt;TObj&amp;gt;().MyArgs myArgs;try { AppCliArgs.Initialize&amp;lt;CliArgsSetup&amp;gt;(); // Parse the data into a give args object (MyArgs) myArgs = AppCliArgs.GetArgsParsed&amp;lt;MyArgs&amp;gt;();}catch(CliArgsException exception){ Console.WriteLine($&quot;Error: {exception.Message}&quot;); return;} // Later you access to the property from everywhere Console.WriteLine($&quot;User age: {myArgs.Age}.&quot;);" }, { "title": "Argument long and short names", "url": "/Cliargs.NET/basic-usage/long-short-names/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The argument long and short names are different than the argument name. The argument name is used as a key when managing the arguments, ex: create argument or get a value of an argument.Argument long nameThe argument long name is usually a single word or a set of words separated by a dash - all in lower case.Argument without value:var myOptionArg = CliArg.New(&quot;ForceUpdate&quot;) .WithLongName(&quot;force-update&quot;);Argument with value:var myOtherArg = CliArg.New&amp;lt;bool&amp;gt;(&quot;ForceUpdate&quot;) .WithLongName(&quot;force-update&quot;);Usage from shell:&amp;gt; myApp --force-update...&amp;gt; myOtherApp --force-update trueArgument short nameThe argument short name is usually a single character or an abbreviation of multiple words in lower case.Argument without value:var myOptionArg = CliArg.New(&quot;ForceUpdate&quot;) .WithShortName(&quot;f&quot;);Argument with value:var myOtherArg = CliArg.New&amp;lt;bool&amp;gt;(&quot;ForceUpdate&quot;) .WithShortName(&quot;f&quot;);Usage from shell&amp;gt; myApp -f...&amp;gt; myOtherApp -f true" }, { "title": "Handle validation errors", "url": "/Cliargs.NET/basic-usage/handle-validation-errors/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "During the initialization, Cliargs.NET execute all the defined rules for each argument, if any rule fails to get validated, Cliargs.NET registers the errors.Check if validation failedTo know if any rule fails to get validated during the validation process, use the static property AppCliArgs.HasValidationErrors.if(AppCliArgs.HasValidationErrors) { // Do stuff}Get validation errorsThe validation errors could be retrieved by calling the static method AppCliArgs.GetValidationResults(). This method returns only validation results for rules failed to get validated.if(AppCliArgs.HasValidationErrors){ // Here you get the validation results for errors var validationResults = AppCliArgs.GetValidationResults(); foreach (var result in validationResults) { // do stuff } return;}Validation resultsThe validation result contains several information about the validation, such as the rule name, the error message… or a global report. The validation result Report is a string contains all the information, rule, message, the usage of the argumet… More info hereif(AppCliArgs.HasValidationErrors){ var validationResults = AppCliArgs.GetValidationResults(); foreach (var result in validationResults) { // Here you access to the results Console.WriteLine(result.GetReport()); Console.WriteLine(result.ValidationError); Console.WriteLine(result.RuleName); Console.WriteLine(result.ArgName); Console.WriteLine(result.Usage); } return;}" }, { "title": "Create argument", "url": "/Cliargs.NET/basic-usage/create-argument/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The argument creation is the first step to setup your configuration, you should know what is the type of the argument’s value, or if the argument is an option without any expected value.Sample argument with no-valueThis is useful when providing the end-user possiblity to input options that don’t require any value. like --help or --force. These are options, and must be handled in a different way.var myOptionArg = CliArg.New(&quot;Force&quot;);The code above create a new instance of an argument having a name Force. if no long name is set, the user must enter --Force during the input.Sample argument with a valueThe arguments with value are used if you expect the user to enter an argument following with a value, ex: --Force true.var myOptionArg = CliArg.New&amp;lt;bool&amp;gt;(&quot;Force&quot;);The code above create a new instance of an argument having a name Force and a value of type bool. if no long name is set, the user must enter --Force true or --Force false during the input." }, { "title": "Help output", "url": "/Cliargs.NET/basic-usage/cliargs-help-output/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Cliargs.NET generates automatically the help output during the initialization step basing on the container configuration. The help output is composed of two columns, the left one is the argument usage, and the right one is the description as set by the developer.If the argument is optional has a default value set, this default value is displayed on the description column.To get the help output use the static method GetHelpString().Console.WriteLine(AppCliArgs.GetHelpString());To check if the end-user has requested to see the help, use the static method IsHelpRequested().if(AppCliArgs.IsHelpRequested()) { Console.WriteLine(AppCliArgs.GetHelpString()); return;}Example output" }, { "title": "Argument Usage", "url": "/Cliargs.NET/basic-usage/argument-usage/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Argument usage is a sample description explaining the usage of the argument, including the short and long names and format.Once the argument usage is set, if the user enters a wrong value, the usage set will be displayed as a hint to help the user correct the input. The argument usage is displayed on the first column on the help output.Usage examplepublic void Configure(ICliArgsContainer container) { // The user real name container.Register( CliArg.New&amp;lt;string&amp;gt;(&quot;Name&quot;) .WithLongName(&quot;name&quot;) .WithShortName(&quot;n&quot;) .WithDescription(&quot;The real name&quot;) // Here is the example usage .WithUsage($&quot;-n|--name \\&quot;John Doe\\&quot;&quot;) .ValidatedWithRule(RegexRule.WithPattern(&quot;/^[a-z ,.&#39;-]+$/i&quot;)) ); }Result on wrong inputResult on help requested To generate a correct help output, Cliargs is generating automatically the argument usage if not set." }, { "title": "Argument Description", "url": "/Cliargs.NET/basic-usage/argument-description/", "categories": "Basic usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The argument description is used usually when displaying a help on user demand. Each argument should have a short description to help user understand what it means.Set argument descriptionThe argument description could be set either by using the Description property of the argument info, or by calling the extension method WithDescription.// Setting the Argument Info property var usernameArg = new CliArg&amp;lt;string&amp;gt;(new CliArgsInfo(&quot;Username&quot;));usernameArg.Info.Description = &quot;The user name in lower case&quot;; // Setting during the argument creation var otherArg = CliArg.New&amp;lt;string&amp;gt;(&quot;Username&quot;) .WithDescription(&quot;The user name in lower case&quot;);Example on results" }, { "title": "Value Converters", "url": "/Cliargs.NET/advanced-usage/value-conversion/", "categories": "Advanced usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The input value is usually converted automatically from string to the argument predefined type, however, in some specific case, you need to customize the conversion behavior, for example, to make short input to help the end-user types in easy and quick way.Native ConvertersDefault ConverterThe default converter is ValueTypeConverterEnum ConverterThe converter is StringToEnumConverterCustom ConvertersTo customize a conversion from the input value, you should create a new class implementing ValueTypeConverter;DefinitionIn the following example, a sample custom converter to convert input values to a named script in the following : “1” =&amp;gt; typeof(uint)“2” =&amp;gt; typeof(int)“3” =&amp;gt; typeof(long)by default, any other value returns typeof(short)public class CustomConverter: ValueTypeConverter{ public override object? GetConverted(Type type, string value) { switch(value) { case &quot;1&quot; : { return typeof(uint); } case &quot;2&quot; : { return typeof(int); } case &quot;3&quot; : { return typeof(long); } default: { return typeof(short); } } }}UsageOnce the custom converter is created, it might be used during the creation of the argument in the Setup class using the CliArg extension method ValueConvertedWith().container.Register( CliArg.New&amp;lt;Type&amp;gt;(&quot;TargetType&quot;) .AsOptional() .WithLongName(&quot;target-type&quot;) .WithShortName(&quot;tt&quot;) .WithDescription(&quot;Choose a target type [1, 2, 3, 4]&quot;) .WithUsage(&quot;-tt|--target-type &amp;lt;type number&amp;gt;&quot;) .ValueConvertedWith(new CustomConverter()) );" }, { "title": "Custom Format", "url": "/Cliargs.NET/advanced-usage/custom-format/", "categories": "Advanced usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "The format is the definition of the prefix for long name and short name of arguments, and the assignation character for setting a value to an argument, this character or symbol is usually located between the argument key and the value, --arg-key=value.Native FormatThe default native format is --long-argument-name argValue -short-name value --option.Custom FormatThe customize the input format you can create your own format class by implementing the base class CliArgsFormat.public class CustomFormat : CliArgsFormat { public CustomFormat() : base(&#39;:&#39;, &quot;/:&quot;, &quot;/&quot;) { } }Then from main specify the Input format to use during the initialization:AppCliArgs.Initialize&amp;lt;CliArgsSetup&amp;gt;(new CustomFormat());Other easy way to do is by creating a new instance from the default format and set the arguments from constructor:// /:long-name=vlaue /short=other-valueAppCliArgs.Initialize&amp;lt;CliArgsSetup&amp;gt;(new CliArgsFormat(&#39;=&#39;, &quot;/:&quot;, &quot;/&quot;));" }, { "title": "Customize default settings", "url": "/Cliargs.NET/advanced-usage/custom-cliargs-settings/", "categories": "Advanced usage", "tags": "", "date": "2022-03-22 00:00:00 +0100", "snippet": "Cliargs.NET comes with some default settings, which could be customized easily.Help argumentThe help argument is registered by default by Cliargs.NET during initialization process, this argument is registered with: Name: Help LongName: help shortName: hYou can customize to any other values by setting properties of Cliargs.CliArgsOptions.HelpArg.Cliargs.CliArgsOptions.HelpArg.Name = &quot;DefaultHelp&quot;;Cliargs.CliArgsOptions.HelpArg.LongName = &quot;default-help&quot;;Cliargs.CliArgsOptions.HelpArg.ShortName = &quot;dh&quot;;Auto generation of long and short namesThis setting is available since version 1.3.0. It allows you to enable or disable the auto generation of the long and short names for a specific arguments if they are not set.To enable this feature, just set the option CliArgsOptions.Container.AutoGenerateNames to true before on app startup and before initializing AppCliArgs.CliArgsOptions.Container.AutoGenerateNames = true; When this option is enabled, the registration of the argument having auto generated names might fail if the container already contains another argument with the same long name or the same short name. Currently not all settings are customizable, I’m working to make Cliargs more customizable than today. If you want to suggest adding more default settings to be customizable, just let me know." } ]
